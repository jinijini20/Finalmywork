Source URL: https://developers.google.com/people/carddav?hl=ko

이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.
Switch to English
홈 [https://developers.google.com/?hl=ko]
제품 [https://developers.google.com/products?hl=ko]
Google Workspace [https://developers.google.com/workspace?hl=ko]
People API [https://developers.google.com/people?hl=ko]
도움이 되었나요?
CardDAV 프로토콜로 연락처 관리
bookmark_border
이 페이지의 내용
사양 [https://developers.google.com/people/carddav?hl=ko#specifications]
Google의 CardDAV에는 OAuth 2.0이 필요합니다. [https://developers.google.com/people/carddav?hl=ko#google%E2%80%99s_carddav_requires_oauth_20]
Google의 CardDAV 서버에 연결 [https://developers.google.com/people/carddav?hl=ko#connecting_to_googles_carddav_server]
리소스 [https://developers.google.com/people/carddav?hl=ko#resources]
연락처 동기화 [https://developers.google.com/people/carddav?hl=ko#synchronizing_contacts]
Google의 CardDAV 프로토콜을 사용하여 연락처를 보고 관리할 수 있습니다.
연락처가 사용자의 Google 계정에 저장됩니다. 대부분의 Google 서비스에는 연락처 목록에 액세스할 수 없습니다. 클라이언트 애플리케이션은 CardDAV API를 사용하여 새 연락처를 만들고, 기존 연락처를 수정 또는 삭제하고, 특정 기준과 일치하는 연락처를 쿼리할 수 있습니다.
사양
전체 사양은 구현되지 않았지만 Apple iOS™ 연락처 [https://support.google.com/contacts/answer/2753077?co=GENIE.Platform%3DiOS&hl=ko] 및 macOS와 같은 많은 클라이언트는 올바르게 상호 운용되어야 합니다.
관련 사양별로 Google의 CardDAV 지원은 다음과 같습니다.
rfc2518: 분산 저작을 위한 HTTP 확장 프로그램(WebDAV) [https://tools.ietf.org/html/rfc2518]
HTTP 메서드 GET, PUT, DELETE, OPTIONS, PROPFIND를 지원합니다.
HTTP 메서드 LOCK, UNLOCK, COPY, MOVE 또는 MKCOL를 지원하지 않습니다.
임의의(사용자 정의) WebDAV 속성을 지원하지 않습니다.
WebDAV 액세스 제어(rfc3744)를 지원하지 않습니다.
rfc5995: POST를 사용하여 WebDAV 컬렉션에 구성원 추가 [https://tools.ietf.org/html/rfc5995] <ph type="x-smartling-placeholder">
</ph>
ID를 지정하지 않고 새 연락처를 만들 수 있습니다.
rfc6352: CardDAV: 웹 분산 작성 및 API에 대한 vCard 확장 프로그램 버전 관리 (WebDAV) [https://tools.ietf.org/html/rfc6352] <ph type="x-smartling-placeholder">
</ph>
HTTP 메서드 REPORT를 지원하지만 정의된 일부 보고서는 구현되지 않습니다.
주 구성원 컬렉션 및 연락처 컬렉션 제공을 지원합니다.
rfc6578: WebDAV를 위한 컬렉션 동기화 [https://tools.ietf.org/html/rfc6578] <ph type="x-smartling-placeholder">
</ph>
클라이언트 애플리케이션은 초기 동기화 후 이 작업 모드로 전환해야 합니다.
rfc6749: OAuth 2.0 승인 프레임워크 [https://tools.ietf.org/html/rfc6749] 및 rfc6750: OAuth 2.0 승인 프레임워크: Bearer 토큰 사용 [https://tools.ietf.org/html/rfc6750] <ph type="x-smartling-placeholder">
</ph>
OAuth 2.0 HTTP 인증을 사용하여 CardDAV 클라이언트 프로그램 인증을 지원합니다. Google에서는 다른 인증 방법을 지원하지 않습니다. 연락처 데이터의 보안을 위해 CardDAV 연결에서 HTTPS [https://en.wikipedia.org/wiki/HTTPS]를 사용해야 합니다.
rfc6764: WebDAV (CalDAV) 캘린더 확장 프로그램 및 WebDAV (CardDAV) vCard 확장 프로그램용 서비스 찾기 [https://tools.ietf.org/html/rfc6764] <ph type="x-smartling-placeholder">
</ph>
CardDAV URL의 부트스트랩은 rfc6764 섹션 6에 따라 실행되어야 합니다.
지원 caldav-ctag-02: CalDAV의 캘린더 컬렉션 항목 태그 (CTag) [https://github.com/apple/ccs-calendarserver/blob/master/doc/Extensions/caldav-ctag.txt] CardDAV와 CalDAV 사양 간에 공유됩니다. 연락처 ctag는 리소스 ETag와 같습니다. 연락처 주소록의 항목이 변경되면 변경됩니다. 이렇게 하면 클라이언트 프로그램이 변경된 연락처를 동기화할 필요가 없음을 빠르게 판단할 수 있습니다.
Google은 연락처 인코딩 형식으로 VCard 3.0을 사용합니다. 다음을 참조하세요. rfc6350: VCard 3.0 [https://tools.ietf.org/html/rfc6350]
Google의 CardDAV에는 OAuth 2.0이 필요합니다.
Google의 CardDAV 인터페이스에는 OAuth 2.0이 필요합니다. OAuth 2.0을 사용하여 Google API에 액세스하는 방법에 관한 자세한 내용은 아래 링크된 문서를 참고하세요.
OAuth 2.0을 사용하여 Google API에 액세스 [https://developers.google.com/identity/protocols/oauth2?hl=ko]
설치된 애플리케이션에 OAuth 2.0 사용 [https://developers.google.com/identity/protocols/oauth2/native-app?hl=ko]
Google의 CardDAV 서버에 연결
CardDAV 프로토콜을 사용하면 주소록과 연락처 리소스를 검색할 수 있습니다. URI. URI는 언제든지 변경될 수 있으므로 URI를 하드코딩해서는 안 됩니다.
클라이언트 애플리케이션은 HTTPS를 사용해야 하며 사용자의 Google 계정에 OAuth 2.0 인증을 제공해야 합니다. CardDAV 서버는 Google 계정의 OAuth 2.0 인증과 함께 HTTPS를 통해 도착하고 애플리케이션이 DevConsole에 등록되어 있지 않으면 요청을 인증하지 않습니다. 기본 인증 또는 이메일/비밀번호가 Google 계정과 일치하지 않으면 HTTP 요청이 401 Unauthorized 응답 코드입니다.
CardDAV를 사용하려면 클라이언트 프로그램이 다음에서 HTTP PROPFIND를 실행하여 처음에 표준 검색 경로에 연결해야 합니다.
https://www.googleapis.com/.well-known/carddav
주소록 리소스로 리디렉션(HTTP 301)되면 클라이언트 프로그램은 주소록 리소스에 대해 PROPFIND를 실행하여 DAV:current-user-principal, DAV:principal-URL, addressbook-home-set 속성을 찾을 수 있습니다. 그러면 클라이언트 프로그램은 addressbook-home-set에서 PROPFIND를 수행하고 addressbook 및 collection 리소스. 이 프로세스에 대한 자세한 설명은 이 문서의 범위를 벗어납니다. 자세한 내용은 rfc6352 [https://tools.ietf.org/html/rfc6352]를 참고하세요.
잘 알려진 URI의 PROPFIND를 통해 HTTP 301 응답으로 반환된 리디렉션 경로는 rfc6764 [https://tools.ietf.org/html/rfc6764]에 따라 영구적으로 캐시되어서는 안 됩니다. 기기는 잘 알려진 URI 검색을 주기적으로 다시 시도하여 캐시된 경로가 여전히 최신 상태인지 확인하고 경로가 변경되면 다시 동기화해야 합니다. 2~4주마다 업데이트하는 것이 좋습니다.
리소스
CardDAV는 REST 개념을 사용합니다. 클라이언트 애플리케이션은 리소스 ID입니다. 개발자가 다음 섹션의 개념을 이해하는 데 도움이 되도록 현재 URI 구조가 여기에 지정되어 있습니다. 구조는 하드코딩되어서는 안 됩니다. 대신 리소스는 RFC에 따라 검색되어야 합니다.
주 구성원 <ph type="x-smartling-placeholder">
</ph>
https://www.googleapis.com/carddav/v1/principals/userEmail
Home Set
https://www.googleapis.com/carddav/v1/principals/userEmail/lists
주소록
https://www.googleapis.com/carddav/v1/principals/userEmail/lists/default
문의
https://www.googleapis.com/carddav/v1/principals/userEmail/lists/default/contactId
연락처 동기화
다음은 지원되는 작업에 대한 일반적인 설명입니다. 개발자는 관련 RFC에서 세부정보를 찾아야 합니다. 요청과 응답은 대부분 XML로 인코딩되어 있습니다. 이것은 클라이언트가 사용하는 기본 작업이며 동기화용 애플리케이션:
CTag 사용 <ph type="x-smartling-placeholder">
</ph>
클라이언트 프로그램은 주소록 리소스의 getctag PROPFIND 요청을 사용하여 서버에서 연락처가 변경되었는지, 따라서 동기화가 필요한지 확인합니다. 이 속성의 값입니다. 연락처가 변경되면 변경됩니다. 클라이언트 애플리케이션 이 값을 저장하고 초기 동기화 시에만 사용해야 하며 sync-token가 무효화될 때 대체를 지원합니다. getctag 속성을 주기적으로 폴링하면 제한이 적용됩니다.
동기화 토큰 사용 <ph type="x-smartling-placeholder">
</ph>
클라이언트 프로그램은 주소록의 sync-token PROPFIND 요청을 사용하여 현재 상태를 나타내는 sync-token를 가져옵니다. 고객 애플리케이션은 이 값을 저장하고 주기적인 sync-collection를 실행해야 합니다. 마지막 요청 이후 변경사항 확인 요청 REPORT건 sync-token입니다. 발급된 토큰은 29일 동안 유효하며, REPORT 응답에는 새로운 sync-token가 포함됩니다.
ETag 사용 <ph type="x-smartling-placeholder">
</ph>
클라이언트 애플리케이션은 주소록 리소스에 getetag PROPFIND 요청을 실행합니다(DEPTH 헤더가 DEPTH_1임). 각 연락처의 ETag 값을 유지하여 클라이언트 프로그램은 ETag가 변경된 연락처의 값을 요청할 수 있습니다.
연락처 가져오기
클라이언트 애플리케이션은 addressbook-multiget REPORT 요청. 연락처 URI 목록이 주어지면 보고서는 요청된 모든 연락처를 VCard 3.0 값으로 반환합니다. 각 항목에는 연락처에 대한 ETag가 포함됩니다.
연락처 삽입
클라이언트 애플리케이션은 VCard 3.0 형식의 새 연락처가 포함된 POST 요청을 실행합니다. 응답에는 새 연락처의 ID가 포함됩니다.
연락처 업데이트 <ph type="x-smartling-placeholder">
</ph>
클라이언트 애플리케이션은 PUT 요청을 통해 업데이트된 연락처로 VCard 3.0 형식 연락처가 이미 주소록에 있는 경우 연락처가 업데이트됩니다.
클라이언트 애플리케이션에는 다음과 같은 If-Match 헤더가 포함되어야 합니다. 연락처의 현재 알려진 ETag입니다. 그러면 서버의 현재 ETag가 클라이언트 프로그램에서 전송한 ETag와 다른 경우 서버는 PUT 요청(HTTP 412 포함)을 거부합니다. 이렇게 하면 업데이트를 낙관적으로 직렬화할 수 있습니다.
연락처 삭제 <ph type="x-smartling-placeholder">
</ph>
클라이언트 애플리케이션은 DELETE 요청을 실행하여 연락처를 삭제합니다. 연락처 URI와 대조합니다.
도움이 되었나요?